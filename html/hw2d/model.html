<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>hw2d.model API documentation</title>
<meta name="description" content="hw2d.model: Hasegawa-Wakatani 2D Simulation Module …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>hw2d.model</code></h1>
</header>
<section id="section-intro">
<p>hw2d.model: Hasegawa-Wakatani 2D Simulation Module</p>
<p>This module provides the core functionality to simulate the Hasegawa-Wakatani (HW) model in two dimensions.
It offers flexibility in terms of numerical schemes and allows for comprehensive profiling and debugging
of the simulation process.</p>
<h2 id="functions">Functions</h2>
<ul>
<li>euler_step: Implements the Euler time-stepping method.</li>
<li>rk4_step: Implements the Runge-Kutta 4th order time-stepping method.</li>
<li>get_phi: Computes the electrostatic potential from vorticity.</li>
<li>diffuse: Applies diffusion to an array.</li>
<li>gradient_2d: Computes the 2D gradient of the system.</li>
<li>get_gammas: Computes energy gradients.</li>
</ul>
<h2 id="classes">Classes</h2>
<ul>
<li>HW: Represents the primary simulation entity for the Hasegawa-Wakatani model.</li>
</ul>
<h2 id="notes">Notes</h2>
<p>The module supports both NumPy and Numba for computational operations and provides detailed logging and
profiling capabilities.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
hw2d.model: Hasegawa-Wakatani 2D Simulation Module

This module provides the core functionality to simulate the Hasegawa-Wakatani (HW) model in two dimensions. 
It offers flexibility in terms of numerical schemes and allows for comprehensive profiling and debugging 
of the simulation process.

Functions:
    - euler_step: Implements the Euler time-stepping method.
    - rk4_step: Implements the Runge-Kutta 4th order time-stepping method.
    - get_phi: Computes the electrostatic potential from vorticity.
    - diffuse: Applies diffusion to an array.
    - gradient_2d: Computes the 2D gradient of the system.
    - get_gammas: Computes energy gradients.

Classes:
    - HW: Represents the primary simulation entity for the Hasegawa-Wakatani model.

Notes:
    The module supports both NumPy and Numba for computational operations and provides detailed logging and 
    profiling capabilities.
&#34;&#34;&#34;
from typing import Tuple
import numpy as np
import matplotlib.pyplot as plt
import time
import pandas as pd

# Local Imports
from hw2d.initializations.fourier_noise import get_fft_noise
from hw2d.utils.namespaces import Namespace

# NumPy Version
from hw2d.arakawa.numpy_arakawa import periodic_arakawa_vec

periodic_arakawa = periodic_arakawa_vec
from hw2d.gradients.numpy_gradients import periodic_laplace_N, periodic_gradient
from hw2d.poisson_solvers.numpy_fourier_poisson import fourier_poisson_double
from hw2d.physical_properties.numpy_properties import *

try:
    # Numba
    from hw2d.arakawa.numba_arakawa import periodic_arakawa_stencil
    from hw2d.gradients.numba_gradients import periodic_laplace_N  # , periodic_gradient

    # from hw2d.poisson_solvers.numba_fourier_poisson import fourier_poisson_double

    periodic_arakawa = periodic_arakawa_stencil
except:
    pass
# Other
# from hw2d.poisson_solvers.pyfftw_fourier_poisson import fourier_poisson_pyfftw


class HW:
    def __init__(
        self,
        dx: float,
        N: int,
        c1: float,
        nu: float,
        k0: float,
        arakawa_coeff: float = 1,
        kappa_coeff: float = 1,
        debug: bool = False,
        TEST_CONSERVATION: bool = True,
    ):
        &#34;&#34;&#34;
        Initialize the Hasegawa-Wakatani (HW) simulation.

        Parameters:
            dx (float): Grid spacing.
            N (int): System size.
            c1 (float): Model-specific parameter.
            nu (float): Diffusion coefficient.
            k0 (float): Fundamental wavenumber.
            arakawa_coeff (float, optional): Coefficient for the Arakawa scheme. Default is 1.
            kappa_coeff (float, optional): Coefficient for d/dy phi. Default is 1.
            debug (bool, optional): Flag to enable debugging mode. Default is False.
            TEST_CONSERVATION (bool, optional): Flag to test conservation properties. Default is True.
        &#34;&#34;&#34;
        # Numerical Schemes
        self.poisson_solver = fourier_poisson_double
        self.diffuse_N = periodic_laplace_N
        self.arakawa = periodic_arakawa
        self.gradient_func = periodic_gradient
        # Physical Values
        self.N = int(N)
        self.c1 = c1
        self.nu = (-1) ** (self.N + 1) * nu
        self.k0 = k0
        self.arakawa_coeff = arakawa_coeff
        self.kappa_coeff = kappa_coeff
        self.dx = dx
        self.L = 2 * np.pi / k0
        # Physical Properties
        self.TEST_CONSERVATION = TEST_CONSERVATION
        # Debug Values
        self.debug = debug
        self.counter = 0
        self.watch_fncs = (
            &#34;rk4_step&#34;,
            &#34;euler_step&#34;,
            &#34;get_phi&#34;,
            &#34;diffuse&#34;,
            &#34;gradient_2d&#34;,
            &#34;arakawa&#34;,
        )
        self.timings = {k: 0 for k in self.watch_fncs}
        self.calls = {k: 0 for k in self.watch_fncs}

    def log(self, name: str, time: float):
        &#34;&#34;&#34;
        Log the time taken by a specific function.

        Parameters:
            name (str): Name of the function.
            time (float): Time taken by the function.
        &#34;&#34;&#34;
        self.timings[name] += time
        self.calls[name] += 1

    def print_log(self):
        &#34;&#34;&#34;Display the timing information for the functions profiled.&#34;&#34;&#34;
        df = pd.DataFrame({&#34;time&#34;: self.timings, &#34;calls&#34;: self.calls})
        df[&#34;time/call&#34;] = df[&#34;time&#34;] / df[&#34;calls&#34;]
        df[&#34;%time&#34;] = df[&#34;time&#34;] / df[&#34;time&#34;][&#34;rk4_step&#34;] * 100
        df.sort_values(&#34;time/call&#34;, inplace=True)
        print(df)

    def euler_step(self, plasma: Namespace, dt: float, dx: float) -&gt; Namespace:
        t0 = time.time()
        d = dt * self.gradient_2d(plasma=plasma, phi=plasma[&#34;phi&#34;], dt=0, dx=dx)
        y = plasma + d
        y[&#34;phi&#34;] = self.get_phi(omega=y.omega, dx=dx)
        y[&#34;age&#34;] = plasma.age + dt
        self.log(&#34;euler_step&#34;, time.time() - t0)
        return y

    def rk4_step(self, plasma: Namespace, dt: float, dx: float) -&gt; Namespace:
        # RK4
        t0 = time.time()
        yn = plasma
        # pn = self.get_phi(omega=yn.omega, dx=dx)  # TODO: only execute for t=0
        pn = yn.phi
        k1 = dt * self.gradient_2d(plasma=yn, phi=pn, dt=0, dx=dx)
        p1 = self.get_phi(omega=(yn + k1 * 0.5).omega, dx=dx)
        k2 = dt * self.gradient_2d(plasma=yn + k1 * 0.5, phi=p1, dt=dt / 2, dx=dx)
        p2 = self.get_phi(omega=(yn + k2 * 0.5).omega, dx=dx)
        k3 = dt * self.gradient_2d(plasma=yn + k2 * 0.5, phi=p2, dt=dt / 2, dx=dx)
        p3 = self.get_phi(omega=(yn + k3).omega, dx=dx)
        k4 = dt * self.gradient_2d(plasma=yn + k3, phi=p3, dt=dt, dx=dx)
        # p4 = self.get_phi(k4.omega)
        # TODO: currently adds two timesteps
        y1 = yn + (k1 + 2 * k2 + 2 * k3 + k4) * (1 / 6)
        phi = self.get_phi(omega=y1.omega, dx=dx)
        self.log(&#34;rk4_step&#34;, time.time() - t0)
        if self.debug:
            print(
                &#34; | &#34;.join(
                    [
                        f&#34;{plasma.age + dt:&lt;7.04g}&#34;,
                        f&#34;{np.max(np.abs(yn.density.data)):&gt;7.02g}&#34;,
                        f&#34;{np.max(np.abs(k1.density.data)):&gt;7.02g}&#34;,
                        f&#34;{np.max(np.abs(k2.density.data)):&gt;7.02g}&#34;,
                        f&#34;{np.max(np.abs(k3.density.data)):&gt;7.02g}&#34;,
                        f&#34;{np.max(np.abs(k4.density.data)):&gt;7.02g}&#34;,
                        f&#34;{time.time()-t0:&gt;6.02f}s&#34;,
                    ]
                )
            )
        # Set properties not valid through y1
        y1[&#34;phi&#34;] = phi
        y1[&#34;age&#34;] = plasma.age + dt
        return y1

    def get_phi(self, omega: np.ndarray, dx: float) -&gt; np.ndarray:
        t0 = time.time()
        o_mean = np.mean(omega)
        centered_omega = omega - o_mean
        phi = self.poisson_solver(tensor=centered_omega, dx=dx)
        self.log(&#34;get_phi&#34;, time.time() - t0)
        return phi

    def diffuse(self, arr: np.ndarray, dx: float, N: int) -&gt; np.ndarray:
        t0 = time.time()
        arr = self.diffuse_N(arr=arr, dx=dx, N=N)
        self.log(&#34;diffuse&#34;, time.time() - t0)
        return arr

    def gradient_2d(
        self,
        plasma: Namespace,
        phi: np.ndarray,
        dt: float,
        dx: float,
        debug: bool = False,
    ) -&gt; np.ndarray:
        arak_comp_o = 0
        arak_comp_n = 0
        kap = 0
        DO = 0
        Dn = 0
        t0 = time.time()
        dy_p = self.gradient_func(phi, dx=dx, axis=0)
        self.log(&#34;gradient_2d&#34;, time.time() - t0)

        # Calculate Gradients
        diff = phi - plasma.density

        # Step 2.1: New Omega.
        o = self.c1 * diff
        if self.arakawa_coeff:
            t0 = time.time()
            arak_comp_o = -self.arakawa_coeff * self.arakawa(
                zeta=phi, psi=plasma.omega, dx=dx
            )
            self.log(&#34;arakawa&#34;, time.time() - t0)
            o += arak_comp_o
        if self.nu:
            Do = self.nu * self.diffuse(arr=plasma.omega, dx=dx, N=self.N)
            o += Do

        # Step 2.2: New Density.
        n = self.c1 * diff
        if self.arakawa_coeff:
            t0 = time.time()
            arak_comp_n = -self.arakawa_coeff * self.arakawa(
                zeta=phi, psi=plasma.density, dx=dx
            )
            self.log(&#34;arakawa&#34;, time.time() - t0)
            n += arak_comp_n
        if self.kappa_coeff:
            kap = -self.kappa_coeff * dy_p
            n += kap
        if self.nu:
            Dn = self.nu * self.diffuse(arr=plasma.density, dx=dx, N=self.N)
            n += Dn

        if debug:
            print(
                &#34;  |  &#34;.join(
                    [
                        f&#34;  dO/dt = {np.max(np.abs(self.c1 * diff)):&gt;8.2g} + {np.max(np.abs(arak_comp_o)):&gt;8.2g} + {np.max(np.abs(DO)):&gt;8.2g}&#34;
                        f&#34;  dn/dt = {np.max(np.abs(self.c1 * diff)):&gt;8.2g} + {np.max(np.abs(arak_comp_n)):&gt;8.2g} + {np.max(np.abs(kap)):&gt;8.2g} + {np.max(np.abs(Dn)):&gt;8.2g}&#34;,
                        f&#34;  dO/dt = {np.mean(self.c1 * diff):&gt;8.2g} + {np.mean(arak_comp_o):&gt;8.2g} + {np.mean(DO):&gt;8.2g}&#34;,
                        f&#34;  dn/dt = {np.mean(self.c1 * diff):&gt;8.2g} + {np.mean(arak_comp_n):&gt;8.2g} + {np.mean(kap):&gt;8.2g} + {np.mean(Dn):&gt;8.2g}&#34;,
                    ]
                )
            )

        return_dict = Namespace(
            density=n,
            omega=o,
            phi=phi,  # NOTE: NOT A GRADIENT
            age=plasma.age + dt,
            dx=dx,
        )

        if self.TEST_CONSERVATION:
            gamma_n, gamma_c = self.get_gammas(plasma.density, phi)
            Dp = self.nu * self.diffuse(arr=phi, dx=dx, N=self.N)
            DE = get_DE(n=plasma.density, p=phi, Dn=Dn, Dp=Dp)
            DU = get_DU(n=plasma.density, o=plasma.omega, Dn=Dn, Dp=Dp)
            dE_dt = get_dE_dt(gamma_n=gamma_n, gamma_c=gamma_c, DE=DE)
            dU_dt = get_dU_dt(gamma_n=gamma_n, DU=DU)
            return_dict[&#34;dE&#34;] = dE_dt
            return_dict[&#34;dU&#34;] = dU_dt

        return return_dict

    def get_gammas(self, n: np.ndarray, p: np.ndarray) -&gt; Tuple[np.ndarray, np.ndarray]:
        # Generate Energy Gradients
        gamma_n = get_gamma_n(n=n, p=p, dx=self.dx)
        gamma_c = get_gamma_c(n=n, p=p, c1=self.c1, dx=self.dx)
        return gamma_n, gamma_c</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="hw2d.model.HW"><code class="flex name class">
<span>class <span class="ident">HW</span></span>
<span>(</span><span>dx: float, N: int, c1: float, nu: float, k0: float, arakawa_coeff: float = 1, kappa_coeff: float = 1, debug: bool = False, TEST_CONSERVATION: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize the Hasegawa-Wakatani (HW) simulation.</p>
<h2 id="parameters">Parameters</h2>
<p>dx (float): Grid spacing.
N (int): System size.
c1 (float): Model-specific parameter.
nu (float): Diffusion coefficient.
k0 (float): Fundamental wavenumber.
arakawa_coeff (float, optional): Coefficient for the Arakawa scheme. Default is 1.
kappa_coeff (float, optional): Coefficient for d/dy phi. Default is 1.
debug (bool, optional): Flag to enable debugging mode. Default is False.
TEST_CONSERVATION (bool, optional): Flag to test conservation properties. Default is True.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HW:
    def __init__(
        self,
        dx: float,
        N: int,
        c1: float,
        nu: float,
        k0: float,
        arakawa_coeff: float = 1,
        kappa_coeff: float = 1,
        debug: bool = False,
        TEST_CONSERVATION: bool = True,
    ):
        &#34;&#34;&#34;
        Initialize the Hasegawa-Wakatani (HW) simulation.

        Parameters:
            dx (float): Grid spacing.
            N (int): System size.
            c1 (float): Model-specific parameter.
            nu (float): Diffusion coefficient.
            k0 (float): Fundamental wavenumber.
            arakawa_coeff (float, optional): Coefficient for the Arakawa scheme. Default is 1.
            kappa_coeff (float, optional): Coefficient for d/dy phi. Default is 1.
            debug (bool, optional): Flag to enable debugging mode. Default is False.
            TEST_CONSERVATION (bool, optional): Flag to test conservation properties. Default is True.
        &#34;&#34;&#34;
        # Numerical Schemes
        self.poisson_solver = fourier_poisson_double
        self.diffuse_N = periodic_laplace_N
        self.arakawa = periodic_arakawa
        self.gradient_func = periodic_gradient
        # Physical Values
        self.N = int(N)
        self.c1 = c1
        self.nu = (-1) ** (self.N + 1) * nu
        self.k0 = k0
        self.arakawa_coeff = arakawa_coeff
        self.kappa_coeff = kappa_coeff
        self.dx = dx
        self.L = 2 * np.pi / k0
        # Physical Properties
        self.TEST_CONSERVATION = TEST_CONSERVATION
        # Debug Values
        self.debug = debug
        self.counter = 0
        self.watch_fncs = (
            &#34;rk4_step&#34;,
            &#34;euler_step&#34;,
            &#34;get_phi&#34;,
            &#34;diffuse&#34;,
            &#34;gradient_2d&#34;,
            &#34;arakawa&#34;,
        )
        self.timings = {k: 0 for k in self.watch_fncs}
        self.calls = {k: 0 for k in self.watch_fncs}

    def log(self, name: str, time: float):
        &#34;&#34;&#34;
        Log the time taken by a specific function.

        Parameters:
            name (str): Name of the function.
            time (float): Time taken by the function.
        &#34;&#34;&#34;
        self.timings[name] += time
        self.calls[name] += 1

    def print_log(self):
        &#34;&#34;&#34;Display the timing information for the functions profiled.&#34;&#34;&#34;
        df = pd.DataFrame({&#34;time&#34;: self.timings, &#34;calls&#34;: self.calls})
        df[&#34;time/call&#34;] = df[&#34;time&#34;] / df[&#34;calls&#34;]
        df[&#34;%time&#34;] = df[&#34;time&#34;] / df[&#34;time&#34;][&#34;rk4_step&#34;] * 100
        df.sort_values(&#34;time/call&#34;, inplace=True)
        print(df)

    def euler_step(self, plasma: Namespace, dt: float, dx: float) -&gt; Namespace:
        t0 = time.time()
        d = dt * self.gradient_2d(plasma=plasma, phi=plasma[&#34;phi&#34;], dt=0, dx=dx)
        y = plasma + d
        y[&#34;phi&#34;] = self.get_phi(omega=y.omega, dx=dx)
        y[&#34;age&#34;] = plasma.age + dt
        self.log(&#34;euler_step&#34;, time.time() - t0)
        return y

    def rk4_step(self, plasma: Namespace, dt: float, dx: float) -&gt; Namespace:
        # RK4
        t0 = time.time()
        yn = plasma
        # pn = self.get_phi(omega=yn.omega, dx=dx)  # TODO: only execute for t=0
        pn = yn.phi
        k1 = dt * self.gradient_2d(plasma=yn, phi=pn, dt=0, dx=dx)
        p1 = self.get_phi(omega=(yn + k1 * 0.5).omega, dx=dx)
        k2 = dt * self.gradient_2d(plasma=yn + k1 * 0.5, phi=p1, dt=dt / 2, dx=dx)
        p2 = self.get_phi(omega=(yn + k2 * 0.5).omega, dx=dx)
        k3 = dt * self.gradient_2d(plasma=yn + k2 * 0.5, phi=p2, dt=dt / 2, dx=dx)
        p3 = self.get_phi(omega=(yn + k3).omega, dx=dx)
        k4 = dt * self.gradient_2d(plasma=yn + k3, phi=p3, dt=dt, dx=dx)
        # p4 = self.get_phi(k4.omega)
        # TODO: currently adds two timesteps
        y1 = yn + (k1 + 2 * k2 + 2 * k3 + k4) * (1 / 6)
        phi = self.get_phi(omega=y1.omega, dx=dx)
        self.log(&#34;rk4_step&#34;, time.time() - t0)
        if self.debug:
            print(
                &#34; | &#34;.join(
                    [
                        f&#34;{plasma.age + dt:&lt;7.04g}&#34;,
                        f&#34;{np.max(np.abs(yn.density.data)):&gt;7.02g}&#34;,
                        f&#34;{np.max(np.abs(k1.density.data)):&gt;7.02g}&#34;,
                        f&#34;{np.max(np.abs(k2.density.data)):&gt;7.02g}&#34;,
                        f&#34;{np.max(np.abs(k3.density.data)):&gt;7.02g}&#34;,
                        f&#34;{np.max(np.abs(k4.density.data)):&gt;7.02g}&#34;,
                        f&#34;{time.time()-t0:&gt;6.02f}s&#34;,
                    ]
                )
            )
        # Set properties not valid through y1
        y1[&#34;phi&#34;] = phi
        y1[&#34;age&#34;] = plasma.age + dt
        return y1

    def get_phi(self, omega: np.ndarray, dx: float) -&gt; np.ndarray:
        t0 = time.time()
        o_mean = np.mean(omega)
        centered_omega = omega - o_mean
        phi = self.poisson_solver(tensor=centered_omega, dx=dx)
        self.log(&#34;get_phi&#34;, time.time() - t0)
        return phi

    def diffuse(self, arr: np.ndarray, dx: float, N: int) -&gt; np.ndarray:
        t0 = time.time()
        arr = self.diffuse_N(arr=arr, dx=dx, N=N)
        self.log(&#34;diffuse&#34;, time.time() - t0)
        return arr

    def gradient_2d(
        self,
        plasma: Namespace,
        phi: np.ndarray,
        dt: float,
        dx: float,
        debug: bool = False,
    ) -&gt; np.ndarray:
        arak_comp_o = 0
        arak_comp_n = 0
        kap = 0
        DO = 0
        Dn = 0
        t0 = time.time()
        dy_p = self.gradient_func(phi, dx=dx, axis=0)
        self.log(&#34;gradient_2d&#34;, time.time() - t0)

        # Calculate Gradients
        diff = phi - plasma.density

        # Step 2.1: New Omega.
        o = self.c1 * diff
        if self.arakawa_coeff:
            t0 = time.time()
            arak_comp_o = -self.arakawa_coeff * self.arakawa(
                zeta=phi, psi=plasma.omega, dx=dx
            )
            self.log(&#34;arakawa&#34;, time.time() - t0)
            o += arak_comp_o
        if self.nu:
            Do = self.nu * self.diffuse(arr=plasma.omega, dx=dx, N=self.N)
            o += Do

        # Step 2.2: New Density.
        n = self.c1 * diff
        if self.arakawa_coeff:
            t0 = time.time()
            arak_comp_n = -self.arakawa_coeff * self.arakawa(
                zeta=phi, psi=plasma.density, dx=dx
            )
            self.log(&#34;arakawa&#34;, time.time() - t0)
            n += arak_comp_n
        if self.kappa_coeff:
            kap = -self.kappa_coeff * dy_p
            n += kap
        if self.nu:
            Dn = self.nu * self.diffuse(arr=plasma.density, dx=dx, N=self.N)
            n += Dn

        if debug:
            print(
                &#34;  |  &#34;.join(
                    [
                        f&#34;  dO/dt = {np.max(np.abs(self.c1 * diff)):&gt;8.2g} + {np.max(np.abs(arak_comp_o)):&gt;8.2g} + {np.max(np.abs(DO)):&gt;8.2g}&#34;
                        f&#34;  dn/dt = {np.max(np.abs(self.c1 * diff)):&gt;8.2g} + {np.max(np.abs(arak_comp_n)):&gt;8.2g} + {np.max(np.abs(kap)):&gt;8.2g} + {np.max(np.abs(Dn)):&gt;8.2g}&#34;,
                        f&#34;  dO/dt = {np.mean(self.c1 * diff):&gt;8.2g} + {np.mean(arak_comp_o):&gt;8.2g} + {np.mean(DO):&gt;8.2g}&#34;,
                        f&#34;  dn/dt = {np.mean(self.c1 * diff):&gt;8.2g} + {np.mean(arak_comp_n):&gt;8.2g} + {np.mean(kap):&gt;8.2g} + {np.mean(Dn):&gt;8.2g}&#34;,
                    ]
                )
            )

        return_dict = Namespace(
            density=n,
            omega=o,
            phi=phi,  # NOTE: NOT A GRADIENT
            age=plasma.age + dt,
            dx=dx,
        )

        if self.TEST_CONSERVATION:
            gamma_n, gamma_c = self.get_gammas(plasma.density, phi)
            Dp = self.nu * self.diffuse(arr=phi, dx=dx, N=self.N)
            DE = get_DE(n=plasma.density, p=phi, Dn=Dn, Dp=Dp)
            DU = get_DU(n=plasma.density, o=plasma.omega, Dn=Dn, Dp=Dp)
            dE_dt = get_dE_dt(gamma_n=gamma_n, gamma_c=gamma_c, DE=DE)
            dU_dt = get_dU_dt(gamma_n=gamma_n, DU=DU)
            return_dict[&#34;dE&#34;] = dE_dt
            return_dict[&#34;dU&#34;] = dU_dt

        return return_dict

    def get_gammas(self, n: np.ndarray, p: np.ndarray) -&gt; Tuple[np.ndarray, np.ndarray]:
        # Generate Energy Gradients
        gamma_n = get_gamma_n(n=n, p=p, dx=self.dx)
        gamma_c = get_gamma_c(n=n, p=p, c1=self.c1, dx=self.dx)
        return gamma_n, gamma_c</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="hw2d.model.HW.diffuse"><code class="name flex">
<span>def <span class="ident">diffuse</span></span>(<span>self, arr: numpy.ndarray, dx: float, N: int) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def diffuse(self, arr: np.ndarray, dx: float, N: int) -&gt; np.ndarray:
    t0 = time.time()
    arr = self.diffuse_N(arr=arr, dx=dx, N=N)
    self.log(&#34;diffuse&#34;, time.time() - t0)
    return arr</code></pre>
</details>
</dd>
<dt id="hw2d.model.HW.euler_step"><code class="name flex">
<span>def <span class="ident">euler_step</span></span>(<span>self, plasma: <a title="hw2d.utils.namespaces.Namespace" href="utils/namespaces.html#hw2d.utils.namespaces.Namespace">Namespace</a>, dt: float, dx: float) ‑> <a title="hw2d.utils.namespaces.Namespace" href="utils/namespaces.html#hw2d.utils.namespaces.Namespace">Namespace</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def euler_step(self, plasma: Namespace, dt: float, dx: float) -&gt; Namespace:
    t0 = time.time()
    d = dt * self.gradient_2d(plasma=plasma, phi=plasma[&#34;phi&#34;], dt=0, dx=dx)
    y = plasma + d
    y[&#34;phi&#34;] = self.get_phi(omega=y.omega, dx=dx)
    y[&#34;age&#34;] = plasma.age + dt
    self.log(&#34;euler_step&#34;, time.time() - t0)
    return y</code></pre>
</details>
</dd>
<dt id="hw2d.model.HW.get_gammas"><code class="name flex">
<span>def <span class="ident">get_gammas</span></span>(<span>self, n: numpy.ndarray, p: numpy.ndarray) ‑> Tuple[numpy.ndarray, numpy.ndarray]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_gammas(self, n: np.ndarray, p: np.ndarray) -&gt; Tuple[np.ndarray, np.ndarray]:
    # Generate Energy Gradients
    gamma_n = get_gamma_n(n=n, p=p, dx=self.dx)
    gamma_c = get_gamma_c(n=n, p=p, c1=self.c1, dx=self.dx)
    return gamma_n, gamma_c</code></pre>
</details>
</dd>
<dt id="hw2d.model.HW.get_phi"><code class="name flex">
<span>def <span class="ident">get_phi</span></span>(<span>self, omega: numpy.ndarray, dx: float) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_phi(self, omega: np.ndarray, dx: float) -&gt; np.ndarray:
    t0 = time.time()
    o_mean = np.mean(omega)
    centered_omega = omega - o_mean
    phi = self.poisson_solver(tensor=centered_omega, dx=dx)
    self.log(&#34;get_phi&#34;, time.time() - t0)
    return phi</code></pre>
</details>
</dd>
<dt id="hw2d.model.HW.gradient_2d"><code class="name flex">
<span>def <span class="ident">gradient_2d</span></span>(<span>self, plasma: <a title="hw2d.utils.namespaces.Namespace" href="utils/namespaces.html#hw2d.utils.namespaces.Namespace">Namespace</a>, phi: numpy.ndarray, dt: float, dx: float, debug: bool = False) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gradient_2d(
    self,
    plasma: Namespace,
    phi: np.ndarray,
    dt: float,
    dx: float,
    debug: bool = False,
) -&gt; np.ndarray:
    arak_comp_o = 0
    arak_comp_n = 0
    kap = 0
    DO = 0
    Dn = 0
    t0 = time.time()
    dy_p = self.gradient_func(phi, dx=dx, axis=0)
    self.log(&#34;gradient_2d&#34;, time.time() - t0)

    # Calculate Gradients
    diff = phi - plasma.density

    # Step 2.1: New Omega.
    o = self.c1 * diff
    if self.arakawa_coeff:
        t0 = time.time()
        arak_comp_o = -self.arakawa_coeff * self.arakawa(
            zeta=phi, psi=plasma.omega, dx=dx
        )
        self.log(&#34;arakawa&#34;, time.time() - t0)
        o += arak_comp_o
    if self.nu:
        Do = self.nu * self.diffuse(arr=plasma.omega, dx=dx, N=self.N)
        o += Do

    # Step 2.2: New Density.
    n = self.c1 * diff
    if self.arakawa_coeff:
        t0 = time.time()
        arak_comp_n = -self.arakawa_coeff * self.arakawa(
            zeta=phi, psi=plasma.density, dx=dx
        )
        self.log(&#34;arakawa&#34;, time.time() - t0)
        n += arak_comp_n
    if self.kappa_coeff:
        kap = -self.kappa_coeff * dy_p
        n += kap
    if self.nu:
        Dn = self.nu * self.diffuse(arr=plasma.density, dx=dx, N=self.N)
        n += Dn

    if debug:
        print(
            &#34;  |  &#34;.join(
                [
                    f&#34;  dO/dt = {np.max(np.abs(self.c1 * diff)):&gt;8.2g} + {np.max(np.abs(arak_comp_o)):&gt;8.2g} + {np.max(np.abs(DO)):&gt;8.2g}&#34;
                    f&#34;  dn/dt = {np.max(np.abs(self.c1 * diff)):&gt;8.2g} + {np.max(np.abs(arak_comp_n)):&gt;8.2g} + {np.max(np.abs(kap)):&gt;8.2g} + {np.max(np.abs(Dn)):&gt;8.2g}&#34;,
                    f&#34;  dO/dt = {np.mean(self.c1 * diff):&gt;8.2g} + {np.mean(arak_comp_o):&gt;8.2g} + {np.mean(DO):&gt;8.2g}&#34;,
                    f&#34;  dn/dt = {np.mean(self.c1 * diff):&gt;8.2g} + {np.mean(arak_comp_n):&gt;8.2g} + {np.mean(kap):&gt;8.2g} + {np.mean(Dn):&gt;8.2g}&#34;,
                ]
            )
        )

    return_dict = Namespace(
        density=n,
        omega=o,
        phi=phi,  # NOTE: NOT A GRADIENT
        age=plasma.age + dt,
        dx=dx,
    )

    if self.TEST_CONSERVATION:
        gamma_n, gamma_c = self.get_gammas(plasma.density, phi)
        Dp = self.nu * self.diffuse(arr=phi, dx=dx, N=self.N)
        DE = get_DE(n=plasma.density, p=phi, Dn=Dn, Dp=Dp)
        DU = get_DU(n=plasma.density, o=plasma.omega, Dn=Dn, Dp=Dp)
        dE_dt = get_dE_dt(gamma_n=gamma_n, gamma_c=gamma_c, DE=DE)
        dU_dt = get_dU_dt(gamma_n=gamma_n, DU=DU)
        return_dict[&#34;dE&#34;] = dE_dt
        return_dict[&#34;dU&#34;] = dU_dt

    return return_dict</code></pre>
</details>
</dd>
<dt id="hw2d.model.HW.log"><code class="name flex">
<span>def <span class="ident">log</span></span>(<span>self, name: str, time: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Log the time taken by a specific function.</p>
<h2 id="parameters">Parameters</h2>
<p>name (str): Name of the function.
time (float): Time taken by the function.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def log(self, name: str, time: float):
    &#34;&#34;&#34;
    Log the time taken by a specific function.

    Parameters:
        name (str): Name of the function.
        time (float): Time taken by the function.
    &#34;&#34;&#34;
    self.timings[name] += time
    self.calls[name] += 1</code></pre>
</details>
</dd>
<dt id="hw2d.model.HW.print_log"><code class="name flex">
<span>def <span class="ident">print_log</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Display the timing information for the functions profiled.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_log(self):
    &#34;&#34;&#34;Display the timing information for the functions profiled.&#34;&#34;&#34;
    df = pd.DataFrame({&#34;time&#34;: self.timings, &#34;calls&#34;: self.calls})
    df[&#34;time/call&#34;] = df[&#34;time&#34;] / df[&#34;calls&#34;]
    df[&#34;%time&#34;] = df[&#34;time&#34;] / df[&#34;time&#34;][&#34;rk4_step&#34;] * 100
    df.sort_values(&#34;time/call&#34;, inplace=True)
    print(df)</code></pre>
</details>
</dd>
<dt id="hw2d.model.HW.rk4_step"><code class="name flex">
<span>def <span class="ident">rk4_step</span></span>(<span>self, plasma: <a title="hw2d.utils.namespaces.Namespace" href="utils/namespaces.html#hw2d.utils.namespaces.Namespace">Namespace</a>, dt: float, dx: float) ‑> <a title="hw2d.utils.namespaces.Namespace" href="utils/namespaces.html#hw2d.utils.namespaces.Namespace">Namespace</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rk4_step(self, plasma: Namespace, dt: float, dx: float) -&gt; Namespace:
    # RK4
    t0 = time.time()
    yn = plasma
    # pn = self.get_phi(omega=yn.omega, dx=dx)  # TODO: only execute for t=0
    pn = yn.phi
    k1 = dt * self.gradient_2d(plasma=yn, phi=pn, dt=0, dx=dx)
    p1 = self.get_phi(omega=(yn + k1 * 0.5).omega, dx=dx)
    k2 = dt * self.gradient_2d(plasma=yn + k1 * 0.5, phi=p1, dt=dt / 2, dx=dx)
    p2 = self.get_phi(omega=(yn + k2 * 0.5).omega, dx=dx)
    k3 = dt * self.gradient_2d(plasma=yn + k2 * 0.5, phi=p2, dt=dt / 2, dx=dx)
    p3 = self.get_phi(omega=(yn + k3).omega, dx=dx)
    k4 = dt * self.gradient_2d(plasma=yn + k3, phi=p3, dt=dt, dx=dx)
    # p4 = self.get_phi(k4.omega)
    # TODO: currently adds two timesteps
    y1 = yn + (k1 + 2 * k2 + 2 * k3 + k4) * (1 / 6)
    phi = self.get_phi(omega=y1.omega, dx=dx)
    self.log(&#34;rk4_step&#34;, time.time() - t0)
    if self.debug:
        print(
            &#34; | &#34;.join(
                [
                    f&#34;{plasma.age + dt:&lt;7.04g}&#34;,
                    f&#34;{np.max(np.abs(yn.density.data)):&gt;7.02g}&#34;,
                    f&#34;{np.max(np.abs(k1.density.data)):&gt;7.02g}&#34;,
                    f&#34;{np.max(np.abs(k2.density.data)):&gt;7.02g}&#34;,
                    f&#34;{np.max(np.abs(k3.density.data)):&gt;7.02g}&#34;,
                    f&#34;{np.max(np.abs(k4.density.data)):&gt;7.02g}&#34;,
                    f&#34;{time.time()-t0:&gt;6.02f}s&#34;,
                ]
            )
        )
    # Set properties not valid through y1
    y1[&#34;phi&#34;] = phi
    y1[&#34;age&#34;] = plasma.age + dt
    return y1</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="hw2d" href="index.html">hw2d</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="hw2d.model.HW" href="#hw2d.model.HW">HW</a></code></h4>
<ul class="two-column">
<li><code><a title="hw2d.model.HW.diffuse" href="#hw2d.model.HW.diffuse">diffuse</a></code></li>
<li><code><a title="hw2d.model.HW.euler_step" href="#hw2d.model.HW.euler_step">euler_step</a></code></li>
<li><code><a title="hw2d.model.HW.get_gammas" href="#hw2d.model.HW.get_gammas">get_gammas</a></code></li>
<li><code><a title="hw2d.model.HW.get_phi" href="#hw2d.model.HW.get_phi">get_phi</a></code></li>
<li><code><a title="hw2d.model.HW.gradient_2d" href="#hw2d.model.HW.gradient_2d">gradient_2d</a></code></li>
<li><code><a title="hw2d.model.HW.log" href="#hw2d.model.HW.log">log</a></code></li>
<li><code><a title="hw2d.model.HW.print_log" href="#hw2d.model.HW.print_log">print_log</a></code></li>
<li><code><a title="hw2d.model.HW.rk4_step" href="#hw2d.model.HW.rk4_step">rk4_step</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>